# -*- coding: utf-8 -*-
"""gas_appliance_data_generator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_vlLfR76kWq4C4Nv2je1S-Js0rkJpvVr
"""

"""
Unified Gas Appliance Synthetic Data Generator
==============================================
Single generator with shared ToU scaffolding for: Stove, Oven, Dryer, Water Heater
Tunable by occupancy; emits per-appliance series OR combined household stream

Author: Madhu Sridhar
"""

import numpy as np
import pandas as pd
import math
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from enum import Enum

# ============================================================================
# GLOBAL CONSTANTS (from empirical research)
# ============================================================================

METER_STEP = 0.01  # Billing floor (therms)
MINUTES_PER_DAY = 24 * 60

class ApplianceType(Enum):
    STOVE = "stove"
    OVEN = "oven"
    DRYER = "dryer"
    WATER_HEATER = "water_heater"

# ============================================================================
# TIME-OF-USE WINDOWS (Shared Scaffolding)
# ============================================================================

@dataclass
class ToUWindow:
    """Time-of-use window in minutes from midnight"""
    start: int
    end: int
    weight: float  # Probability weight

class ToUManager:
    """Manages shared time-of-use patterns across appliances"""

    # Base windows (weekday)
    BREAKFAST = ToUWindow(6*60, 9*60, 0.25)
    LUNCH = ToUWindow(11*60, 14*60, 0.15)
    DINNER = ToUWindow(17*60, 20*60, 0.40)
    EVENING = ToUWindow(18*60, 22*60, 0.20)

    WEEKEND_SLACK_MIN = 60  # Broaden windows by Â±1hr on weekends

    @staticmethod
    def is_weekend(day_idx: int) -> bool:
        """Check if day index (0-6) is weekend"""
        return (day_idx % 7) in (5, 6)

    @staticmethod
    def broaden_window(window: ToUWindow, slack: int) -> ToUWindow:
        """Expand window by slack minutes on each side"""
        return ToUWindow(
            max(0, window.start - slack),
            min(MINUTES_PER_DAY - 1, window.end + slack),
            window.weight
        )

    @staticmethod
    def sample_from_windows(windows: List[ToUWindow], rng, day_idx: int = 0) -> int:
        """Sample start time from weighted windows"""
        if ToUManager.is_weekend(day_idx):
            windows = [ToUManager.broaden_window(w, ToUManager.WEEKEND_SLACK_MIN)
                      for w in windows]

        # Normalize weights
        total_weight = sum(w.weight for w in windows)
        probs = [w.weight / total_weight for w in windows]

        # Pick window
        selected = rng.choice(len(windows), p=probs)
        window = windows[selected]

        # Random time within window
        return int(rng.integers(window.start, window.end))

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

def ceil_to_step(x: float, step: float = METER_STEP) -> float:
    """Ceiling to billing step (0.01 therm minimum)"""
    if x <= 0:
        return 0.00
    return round(math.ceil(x / step) * step, 2)

def lognormal_duration(median: int, sigma: float, min_val: int, rng) -> int:
    """Sample duration from lognormal distribution"""
    mu = math.log(median)
    val = int(rng.lognormal(mu, sigma))
    return max(min_val, val)

# ============================================================================
# STOVE GENERATOR
# ============================================================================

class StoveGenerator:
    """Gas stovetop burner usage generator"""

    # Burner configurations
    BTU_POOL = [5000, 9000, 11000, 16000]
    # Probabilities MUST sum to exactly 1.0: 0.55 + 0.25 + 0.10 + 0.10 = 1.0
    BURNER_DIST = {1: 0.55, 2: 0.25, 3: 0.10, 4: 0.10}
    SEQ_SAME_HOUR_PROB = 0.10

    # Duty cycle
    DUTY_MEAN = 0.09
    DUTY_SD = 0.03
    DUTY_CLIP = (0.05, 0.25)

    # Duration (minutes)
    DUR_MEDIAN = 28
    DUR_SIGMA = 0.45
    DUR_MIN = 5

    # Frequency (events per week by household size)
    @staticmethod
    def events_per_week(people: int) -> int:
        """Cooking events per week scales with occupancy"""
        base = {1: 8, 2: 12, 3: 16, 4: 20, 5: 24}
        return base.get(people, 24 + (people - 5) * 4)

    def __init__(self, rng):
        self.rng = rng

    def draw_duty(self) -> float:
        """Sample duty cycle"""
        return float(np.clip(
            self.rng.normal(self.DUTY_MEAN, self.DUTY_SD),
            *self.DUTY_CLIP
        ))

    def burners_active(self) -> Tuple[int, bool]:
        """Return (num_burners, sequential_flag)"""
        k = self.rng.choice(
            list(self.BURNER_DIST.keys()),
            p=list(self.BURNER_DIST.values())
        )
        seq = self.rng.random() < self.SEQ_SAME_HOUR_PROB
        return k, seq

    def add_session(self, ts: np.ndarray, start_min: int, duration: int):
        """Add one cooking session to hourly timeseries"""
        left, t = duration, start_min
        k, seq_flag = self.burners_active()

        while left > 0:
            h = t // 60
            if h > 23:
                break

            in_hour = min(left, 60 - (t % 60))
            touches = 2 if (seq_flag and in_hour >= 16) else 1
            therms = 0.0

            for _ in range(touches):
                minutes = in_hour / touches
                for _ in range(k):
                    btu = self.rng.choice(self.BTU_POOL)
                    dc = self.draw_duty()
                    therms += (btu * dc * (minutes / 60)) / 100000.0

            ts[h] += therms
            left -= in_hour
            t += in_hour

    def generate_day(self, people: int, day_idx: int) -> np.ndarray:
        """Generate one day of stove usage"""
        ts = np.zeros(24)

        # Events per day from weekly frequency
        weekly = self.events_per_week(people)
        day_prob = weekly / 7.0
        events_today = self.rng.poisson(day_prob)

        # Define meal windows
        windows = [ToUManager.BREAKFAST, ToUManager.LUNCH, ToUManager.DINNER]

        for _ in range(events_today):
            start = ToUManager.sample_from_windows(windows, self.rng, day_idx)
            duration = lognormal_duration(self.DUR_MEDIAN, self.DUR_SIGMA,
                                         self.DUR_MIN, self.rng)
            self.add_session(ts, start, duration)

        return np.array([ceil_to_step(v) for v in ts])

# ============================================================================
# OVEN GENERATOR
# ============================================================================

class OvenGenerator:
    """Gas oven usage generator"""

    # Oven power
    BTU_POOL = [16000, 18000, 21000, 24000, 26000]

    # Duration
    DUR_MEDIAN = 55
    DUR_SIGMA = 0.45
    DUR_MIN = 20

    # Duty cycle (preheat + hold)
    PREHEAT_MIN = (10, 15)
    PREHEAT_DUTY = (0.80, 1.00)
    HOLD_DUTY_MEAN = 0.30
    HOLD_DUTY_SD = 0.08
    HOLD_DUTY_CLIP = (0.15, 0.55)

    # Frequency (uses per week)
    FREQ_BINS = [(0, 0), (1, 3), (4, 7), (8, 14)]
    FREQ_WEIGHTS = [0.18, 0.57, 0.23, 0.02]

    def __init__(self, rng):
        self.rng = rng

    def sample_weekly_uses(self) -> int:
        """Sample oven uses per week"""
        bin_idx = self.rng.choice(len(self.FREQ_BINS), p=self.FREQ_WEIGHTS)
        lo, hi = self.FREQ_BINS[bin_idx]
        return 0 if hi == 0 else int(self.rng.integers(lo, hi + 1))

    def add_session(self, ts: np.ndarray, start_min: int, total_min: int, btu: int):
        """Add oven session with preheat + hold phases"""
        # Preheat
        pre_mins = min(total_min, int(self.rng.integers(*self.PREHEAT_MIN)))
        hold_mins = max(0, total_min - pre_mins)

        # Preheat phase (near-continuous)
        for m in range(pre_mins):
            duty = self.rng.uniform(*self.PREHEAT_DUTY)
            h = (start_min + m) // 60
            if h > 23:
                break
            ts[h] += (btu * duty / 100000.0) / 60.0

        # Hold phase (cycling)
        for m in range(hold_mins):
            duty = float(np.clip(
                self.rng.normal(self.HOLD_DUTY_MEAN, self.HOLD_DUTY_SD),
                *self.HOLD_DUTY_CLIP
            ))
            tmin = start_min + pre_mins + m
            h = tmin // 60
            if h > 23:
                break
            ts[h] += (btu * duty / 100000.0) / 60.0

    def generate_day(self, people: int, day_idx: int) -> np.ndarray:
        """Generate one day of oven usage"""
        ts = np.zeros(24)

        # Weekly uses distributed across days (weekend bias)
        weekly = self.sample_weekly_uses()
        day_weights = np.array([0.9, 0.9, 1.0, 1.0, 1.2, 1.3, 1.3])
        day_weights = day_weights / day_weights.sum()
        expected = weekly * day_weights[day_idx % 7]

        # Scale by people (slight increase)
        expected *= (1.0 + (people - 3) * 0.1)

        n_sessions = self.rng.poisson(max(0, expected))

        # Oven mainly used for dinner
        windows = [ToUManager.BREAKFAST, ToUManager.DINNER]
        weights_override = [ToUWindow(w.start, w.end, 0.2 if i == 0 else 0.8)
                           for i, w in enumerate(windows)]

        for _ in range(n_sessions):
            start = ToUManager.sample_from_windows(weights_override, self.rng, day_idx)
            duration = lognormal_duration(self.DUR_MEDIAN, self.DUR_SIGMA,
                                         self.DUR_MIN, self.rng)
            btu = self.rng.choice(self.BTU_POOL)
            self.add_session(ts, start, duration, btu)

        return np.array([ceil_to_step(v) for v in ts])

# ============================================================================
# DRYER GENERATOR
# ============================================================================

class DryerGenerator:
    """Gas clothes dryer usage generator"""

    # Burner input
    BTU_POOL = [18000, 20000, 22000, 24000]

    # Cycles per week
    CYCLES_MEAN = 5.4
    CYCLES_SD = 2.0

    # Duration
    DUR_MEDIAN = 62
    DUR_SIGMA = 0.35
    DUR_MIN = 40
    COOLDOWN_MIN = (5, 10)

    # Duty cycle
    WARMUP_MIN = (5, 10)
    WARMUP_DUTY = (0.85, 1.00)
    REGULATE_DUTY_MEAN = 0.58
    REGULATE_DUTY_SD = 0.12
    REGULATE_DUTY_CLIP = (0.30, 0.85)
    COOLDOWN_DUTY = (0.10, 0.20)

    # Batching
    BATCH_PROB = 0.35
    BATCH_GAP_MIN = (65, 90)

    def __init__(self, rng):
        self.rng = rng

    def add_cycle(self, ts: np.ndarray, start_min: int, total_min: int, btu: int):
        """Add dryer cycle with warmup + regulate + cooldown"""
        # Phase durations
        wmins = min(total_min, int(self.rng.integers(*self.WARMUP_MIN)))
        cmins = min(max(0, total_min - wmins), int(self.rng.integers(*self.COOLDOWN_MIN)))
        rmins = max(0, total_min - wmins - cmins)

        # Warmup
        for m in range(wmins):
            duty = self.rng.uniform(*self.WARMUP_DUTY)
            h = (start_min + m) // 60
            if h > 23:
                break
            ts[h] += (btu * duty / 100000.0) / 60.0

        # Regulate
        for m in range(rmins):
            duty = float(np.clip(
                self.rng.normal(self.REGULATE_DUTY_MEAN, self.REGULATE_DUTY_SD),
                *self.REGULATE_DUTY_CLIP
            ))
            tmin = start_min + wmins + m
            h = tmin // 60
            if h > 23:
                break
            ts[h] += (btu * duty / 100000.0) / 60.0

        # Cooldown
        for m in range(cmins):
            duty = self.rng.uniform(*self.COOLDOWN_DUTY)
            tmin = start_min + wmins + rmins + m
            h = tmin // 60
            if h > 23:
                break
            ts[h] += (btu * duty / 100000.0) / 60.0

    def generate_day(self, people: int, day_idx: int) -> np.ndarray:
        """Generate one day of dryer usage"""
        ts = np.zeros(24)

        # Weekly loads scale with people
        weekly_loads = self.CYCLES_MEAN + max(0, people - 1) * 0.8

        # Distribute to days (weekend heavy)
        day_weights = np.array([0.9, 0.95, 1.0, 1.0, 1.15, 1.35, 1.35])
        day_weights = day_weights / day_weights.sum()
        expected = weekly_loads * day_weights[day_idx % 7]

        loads_today = self.rng.poisson(max(0, expected))

        if loads_today == 0:
            return np.array([0.00] * 24)

        # Batching logic
        if loads_today > 1 and self.rng.random() < self.BATCH_PROB:
            # Back-to-back loads
            is_weekend = ToUManager.is_weekend(day_idx)
            if is_weekend:
                start = int(self.rng.integers(10*60, 14*60))
            else:
                start = int(self.rng.integers(18*60, 21*60))

            for i in range(loads_today):
                if start >= 23*60:
                    break
                duration = lognormal_duration(self.DUR_MEDIAN, self.DUR_SIGMA,
                                             self.DUR_MIN, self.rng)
                btu = self.rng.choice(self.BTU_POOL)
                self.add_cycle(ts, start, duration, btu)
                start += int(self.rng.integers(*self.BATCH_GAP_MIN))
        else:
            # Spread throughout day
            windows = [ToUWindow(12*60, 14*60, 0.4), ToUWindow(18*60, 21*60, 0.6)]
            for _ in range(loads_today):
                start = ToUManager.sample_from_windows(windows, self.rng, day_idx)
                duration = lognormal_duration(self.DUR_MEDIAN, self.DUR_SIGMA,
                                             self.DUR_MIN, self.rng)
                btu = self.rng.choice(self.BTU_POOL)
                self.add_cycle(ts, start, duration, btu)

        return np.array([ceil_to_step(v) for v in ts])

# ============================================================================
# WATER HEATER GENERATOR
# ============================================================================

class WaterHeaterGenerator:
    """Gas water heater usage generator"""

    # Storage vs Tankless
    STOR_INPUT_BTU_HR = 40000
    STOR_EFF = 0.66
    STANDBY_BTU_HR = 400

    TANK_INPUT_BTU_HR = 160000
    TANK_EFF = 0.90

    # Temperature
    DELTA_T_F = 60.0
    BTU_PER_GAL = 8.34 * DELTA_T_F  # = 500.4

    # Usage profiles (gallons/day per person)
    USAGE_PROFILES = {"low": 40.0, "med": 60.0, "high": 80.0}
    GPP_RANGE = (12.0, 18.0)  # Gallons per extra person

    # Event parameters
    SHOWER_PPP = (0.7, 1.1)  # Per person per day
    SHOWER_DUR = (6, 10)
    SHOWER_FLOW = (1.8, 2.5)
    SHOWER_HOT_FRAC = (0.60, 0.75)

    SINK_PPP = (6, 12)
    SINK_VOL = (0.2, 0.5)
    SINK_HOT_FRAC = (0.50, 0.80)

    DISH_CPD = (0.2, 0.6)
    DISH_GAL = (3.0, 6.0)

    WASHER_CPD = (0.2, 0.5)
    WASHER_GAL = (4.0, 12.0)

    def __init__(self, rng, heater_type: str = "storage"):
        self.rng = rng
        self.heater_type = heater_type

    def gen_events(self, people: int, day_idx: int) -> List[Tuple[int, float]]:
        """Generate (start_min, gallons) hot water events"""
        is_weekend = ToUManager.is_weekend(day_idx)
        events = []

        # Showers (AM peak)
        n_showers = int(round(self.rng.uniform(*self.SHOWER_PPP) * people))
        for _ in range(n_showers):
            dur = self.rng.integers(*self.SHOWER_DUR)
            flow = self.rng.uniform(*self.SHOWER_FLOW)
            frac = self.rng.uniform(*self.SHOWER_HOT_FRAC)
            gal = dur * flow * frac

            # 70% morning, 30% evening
            if self.rng.random() < 0.7:
                window = ToUManager.BREAKFAST
            else:
                window = ToUManager.EVENING

            if is_weekend:
                window = ToUManager.broaden_window(window, 60)

            start = int(self.rng.integers(window.start, window.end))
            events.append((start, gal))

        # Sinks (distributed)
        n_sinks = int(round(self.rng.uniform(*self.SINK_PPP) * people))
        for _ in range(n_sinks):
            vol = self.rng.uniform(*self.SINK_VOL) * self.rng.uniform(*self.SINK_HOT_FRAC)
            # Random meal time
            windows = [ToUManager.BREAKFAST, ToUManager.LUNCH, ToUManager.DINNER]
            window = self.rng.choice(windows)
            if is_weekend:
                window = ToUManager.broaden_window(window, 60)
            start = int(self.rng.integers(window.start, window.end))
            events.append((start, vol))

        # Dishwasher (evening)
        if self.rng.random() < self.rng.uniform(*self.DISH_CPD):
            gal = self.rng.uniform(*self.DISH_GAL)
            window = ToUManager.EVENING
            if is_weekend:
                window = ToUManager.broaden_window(window, 60)
            start = int(self.rng.integers(window.start, window.end))
            events.append((start, gal))

        # Clothes washer
        if self.rng.random() < self.rng.uniform(*self.WASHER_CPD):
            gal = self.rng.uniform(*self.WASHER_GAL)
            windows = [ToUWindow(10*60, 14*60, 0.6), ToUManager.EVENING]
            window = self.rng.choice(windows)
            if is_weekend:
                window = ToUManager.broaden_window(window, 60)
            start = int(self.rng.integers(window.start, window.end))
            events.append((start, gal))

        return sorted(events, key=lambda x: x[0])

    def allocate_recovery(self, ts: np.ndarray, start_min: int, on_minutes: float,
                         input_btu_hr: float):
        """Allocate burner on-time to hourly buckets"""
        btu_per_min = input_btu_hr / 60.0
        for m in range(int(on_minutes)):
            t = start_min + m
            if t >= MINUTES_PER_DAY:
                break
            h = t // 60
            ts[h] += btu_per_min / 100000.0

    def generate_day(self, people: int, day_idx: int, usage: str = "med") -> np.ndarray:
        """Generate one day of water heater usage"""
        ts = np.zeros(24)
        events = self.gen_events(people, day_idx)

        if self.heater_type == "storage":
            # Standby baseline
            for h in range(24):
                ts[h] += max(0.0, self.STANDBY_BTU_HR / 100000.0)

            # Process events
            for start_min, gal in events:
                required_btu = gal * self.BTU_PER_GAL
                input_btu = required_btu / self.STOR_EFF
                on_min = (input_btu / self.STOR_INPUT_BTU_HR) * 60.0
                self.allocate_recovery(ts, start_min, on_min, self.STOR_INPUT_BTU_HR)

        else:  # tankless
            for start_min, gal in events:
                required_btu = gal * self.BTU_PER_GAL
                input_btu = required_btu / self.TANK_EFF
                on_min = (input_btu / self.TANK_INPUT_BTU_HR) * 60.0
                self.allocate_recovery(ts, start_min, on_min, self.TANK_INPUT_BTU_HR)

        return np.array([ceil_to_step(v) for v in ts])

# ============================================================================
# UNIFIED HOUSEHOLD GENERATOR
# ============================================================================

class HouseholdGasGenerator:
    """
    Unified generator for all gas appliances in a household

    Emits:
    - Per-appliance hourly therms
    - Combined household hourly therms
    - Ground truth labels for appliance classification
    """

    def __init__(self, seed: int = 42):
        self.rng = np.random.default_rng(seed)

        # Initialize appliance generators
        self.stove = StoveGenerator(self.rng)
        self.oven = OvenGenerator(self.rng)
        self.dryer = DryerGenerator(self.rng)
        self.water_heater = WaterHeaterGenerator(self.rng, heater_type="storage")

    def generate_day(self, people: int, day_idx: int,
                    appliances: Optional[List[str]] = None) -> Dict[str, np.ndarray]:
        """
        Generate one day of gas usage

        Args:
            people: Number of occupants
            day_idx: Day index (0-6 for weekly patterns)
            appliances: List of appliances to include. If None, include all.

        Returns:
            Dictionary with keys:
                - 'stove': hourly therms
                - 'oven': hourly therms
                - 'dryer': hourly therms
                - 'water_heater': hourly therms
                - 'total': combined hourly therms
        """
        if appliances is None:
            appliances = ['stove', 'oven', 'dryer', 'water_heater']

        result = {}

        if 'stove' in appliances:
            result['stove'] = self.stove.generate_day(people, day_idx)
        else:
            result['stove'] = np.zeros(24)

        if 'oven' in appliances:
            result['oven'] = self.oven.generate_day(people, day_idx)
        else:
            result['oven'] = np.zeros(24)

        if 'dryer' in appliances:
            result['dryer'] = self.dryer.generate_day(people, day_idx)
        else:
            result['dryer'] = np.zeros(24)

        if 'water_heater' in appliances:
            result['water_heater'] = self.water_heater.generate_day(people, day_idx)
        else:
            result['water_heater'] = np.zeros(24)

        # Combined total
        total = np.zeros(24)
        for app in appliances:
            total += result[app]

        # Re-apply rounding to combined (important for billing accuracy)
        result['total'] = np.array([ceil_to_step(v) for v in total])

        return result

    def generate_week(self, people: int, appliances: Optional[List[str]] = None,
                     start_date: Optional[datetime] = None) -> pd.DataFrame:
        """
        Generate a full week of data

        Returns DataFrame with columns:
            - date, hour, stove, oven, dryer, water_heater, total
        """
        if start_date is None:
            start_date = datetime(2024, 8, 1)

        data = []
        for day_idx in range(7):
            day_data = self.generate_day(people, day_idx, appliances)
            current_date = start_date + timedelta(days=day_idx)

            for hour in range(24):
                row = {
                    'date': current_date.strftime('%Y-%m-%d'),
                    'hour': hour,
                    'stove': day_data['stove'][hour],
                    'oven': day_data['oven'][hour],
                    'dryer': day_data['dryer'][hour],
                    'water_heater': day_data['water_heater'][hour],
                    'total': day_data['total'][hour]
                }
                data.append(row)

        return pd.DataFrame(data)

    def generate_month(self, people: int, appliances: Optional[List[str]] = None,
                      start_date: Optional[datetime] = None, days: int = 30) -> pd.DataFrame:
        """Generate a month of synthetic data"""
        if start_date is None:
            start_date = datetime(2024, 8, 1)

        data = []
        for day_num in range(days):
            day_idx = day_num % 7  # Weekly pattern
            day_data = self.generate_day(people, day_idx, appliances)
            current_date = start_date + timedelta(days=day_num)

            for hour in range(24):
                row = {
                    'date': current_date.strftime('%Y-%m-%d'),
                    'hour': hour,
                    'stove': day_data['stove'][hour],
                    'oven': day_data['oven'][hour],
                    'dryer': day_data['dryer'][hour],
                    'water_heater': day_data['water_heater'][hour],
                    'total': day_data['total'][hour]
                }
                data.append(row)

        return pd.DataFrame(data)

# ============================================================================
# MAIN / EXAMPLES
# ============================================================================

if __name__ == "__main__":
    print("=" * 70)
    print("UNIFIED GAS APPLIANCE SYNTHETIC DATA GENERATOR")
    print("=" * 70)

    # Example 1: Generate a week for a 3-person household (all appliances)
    print("\n1. Generating week for 3-person household (all appliances)...")
    gen = HouseholdGasGenerator(seed=42)
    week_data = gen.generate_week(people=3)
    print(week_data.head(24))
    print(f"\nDaily totals (first 7 days):")
    daily = week_data.groupby('date')['total'].sum()
    print(daily)

    # Example 2: Generate data with only stove + water heater
    print("\n2. Generating week for 4-person household (stove + water_heater only)...")
    week_data_limited = gen.generate_week(people=4, appliances=['stove', 'water_heater'])
    print(f"\nAppliance contributions (first day):")
    day1 = week_data_limited[week_data_limited['date'] == week_data_limited['date'].iloc[0]]
    print(f"Stove total: {day1['stove'].sum():.2f} therms")
    print(f"Water heater total: {day1['water_heater'].sum():.2f} therms")
    print(f"Combined total: {day1['total'].sum():.2f} therms")

    # Example 3: Compare different household sizes
    print("\n3. Comparing household sizes (1-5 people)...")
    for people in range(1, 6):
        week = gen.generate_week(people=people)
        total_therms = week['total'].sum()
        print(f"{people} person(s): {total_therms:.2f} therms/week")

    print("\n" + "=" * 70)
    print("Generation complete!")
    print("=" * 70)